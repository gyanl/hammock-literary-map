<!DOCTYPE html>
<html lang="en">

<head>

  <title>Hammock | Literary Map</title>

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Discover great fiction writers from around the globe.">


  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

  <!-- Stylesheets -->
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/v3.1.2/mapbox-gl.css">
  <!-- Link to Google Fonts for Instrument Sans -->
  <link href="https://fonts.googleapis.com/css2?family=Instrument+Sans&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Instrument+Sans:wght@500&display=swap" rel="stylesheet">
  <!-- Scripts -->
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.1.2/mapbox-gl.js"></script>
  <script src="https://unpkg.com/@mapbox/mapbox-sdk/umd/mapbox-sdk.min.js"></script>
  <script src="js/slideshow.js"></script>

  <!-- Open Graph Tags -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:image" content="https://map.hammockmag.com/img/hammock-og.jpg" />
  <meta name="twitter:title" content="Literary Map by Hammock" />
  <meta name="twitter:description" content="Discover great fiction writers from around the globe." />
  
  <meta property="og:title" content="Literary Map by Hammock">
  <meta property="og:description" content="Discover great fiction writers from around the globe.">
  <meta property="og:image" content="https://map.hammockmag.com/img/hammock-og.jpg">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:url" content="https://map.hammockmag.com/">
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Literary Map by Hammock" />
  <meta property="og:article:author" content="Hammock Magazine" />

</head>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZZ3TJ4YXFD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-ZZ3TJ4YXFD');
</script>


<body>

  <div id="aboutPk" class="about-pk displaynone">
    <p>
      We're <span class="white">Public Knowledge Studio</span>, a design and development studio based out of <span
        class="white">New Delhi, India</span>.
    </p>

    <p>We specialize in imaginative and <span class="white">hand-crafted digital
        experiences.</span>
    </p>
  </div>

  <button type="button" class="button-tertiary landing header-fade-in-up" id="aboutButton">
    About this Map <img class="icon-circle" src="icons/info.svg" width="16px" alt="info">
  </button>
  <div id="aboutContainer" class="about-container displaynone header-fade-in-down-fast">

    <h3>About this Map</h3>

    <div class="about-content">
      <p>
        At Hammock, one of our core pillars is providing literary <a class="link-green"
          href="https://www.hammockmag.com/recommendations-lists/" target="_blank">recommendations</a> and curated lists
        to help readers
        discover new books. This interactive map is our latest endeavor to make exploring the world of literature
        engaging and intuitive.
      </p>
      <p>
        With this tool, you can journey across the globe and uncover nearly 800 fiction authors from the 20th and 21st
        centuries, offering a unique glimpse into the geographical roots and top books of some of the world&rsquo;s most
        celebrated writers. Using a range of awards, panel suggestions and other criteria, we&rsquo;ve picked out who we
        think
        are amongst the most essential writers of the past century and a half for you to explore.
      </p>

      <a href="https://www.hammockmag.com/methodology-1/blog-post-one" target="_blank">
        <button type="button" class="button-gray">
          Read About Our Methodology
          <img class="icon-circle-white" src="icons/arrow-up-right-gray.svg" width="16px" alt="info">
        </button>
      </a>

      <hr>
      <h3>Crafted by</h3>
      <a href="https://www.publicknowledge.co" target="_blank">
        <button type="button" class="button-pk cool-effect" id="aboutPkButton">
          <img class="icon-circle-transparent rotate-on-hover" src="icons/pk.svg" width="24px" alt="info">
          Public Knowledge Studio
          <img class="icon-circle-transparent on-hover-colorful" src="icons/arrow-up-right-red.svg" width="16px"
            alt="info">
        </button>
      </a>

    </div>
  </div>

  <div id="introText" class="landing header-fade-in-up">
    <span class="bold">Literary Map</span> by
    <img class="logo" src="hammock-white.png">
    <h1 class="max-width">
      Discover great fiction writers from around the globe
      <button id="introButton" type="button" class="inline button-tertiary">
        Start Exploring <img class="icon-circle-dark" src="icons/arrow-right.svg" width="16px" alt="chevron">
      </button>
    </h1>

  </div>

  <div id="tutorial-bottom" class="center-align bottom-center header-fade-in-down">

    <div class="tutorial-card-container" id="slideshow-container">
      <div class="tutorial-card glass">
        <img src="icons/maximize-2.svg" alt="zoom">
        Scroll or pinch to zoom in and out.
      </div>

      <div class="tutorial-card glass">
        <img src="icons/move.svg" alt="zoom">
        Click and drag to move around the globe.
      </div>

      <div class="tutorial-card glass">
        <img src="icons/mouse-pointer.svg" alt="zoom">
        Click on a green dot to see more about the authors.
      </div>
    </div>


  </div>

  <div id="map"></div>


  <header id="header" class="glass displaynone">
    <a href="https://www.hammockmag.com" id="logo" class="header-logo"></a>


    <div id="filter-container" class="header-links only-on-big-screens">
      <div id="filter-back-button" class="icon-circle only-on-small-screens"><img width="20px"
          src="icons/arrow-left.svg" alt="back"></div>
      <div class="header-link dropdown" id="continent-dropdown">
        <img class="filter-category-icon" src="icons/green/map.svg" alt="Continents Icon">
        Continents
        <div class="dropdown-content">
          <label><input type="checkbox"> Africa</label>
          <label><input type="checkbox"> Asia</label>
          <label><input type="checkbox"> Australia</label>
          <label><input type="checkbox"> Europe</label>
          <label><input type="checkbox"> North America</label>
          <label><input type="checkbox"> Latin America</label>
        </div>
      </div>

      <div class="header-link dropdown" id="gender-dropdown">
        <img class="filter-category-icon" src="icons/green/users.svg" alt="Gender Icon">
        Gender
        <div class="dropdown-content">
          <label><input type="checkbox"> Male</label>
          <label><input type="checkbox"> Female</label>
          <label><input type="checkbox"> Non-binary</label>
        </div>
      </div>

      <div class="header-link dropdown" id="awards-dropdown">
        <img class="filter-category-icon" src="icons/green/award.svg" alt="Awards Icon">
        Awards
        <div class="dropdown-content">
          <label><input type="checkbox"> Booker Prize</label>
          <label><input type="checkbox"> Buchner Prize</label>
          <label><input type="checkbox"> Camoes Prize</label>
          <label><input type="checkbox"> Cervantes Prize</label>
          <label><input type="checkbox"> Commonwealth Prize</label>
          <label><input type="checkbox"> Commonwealth Writers' Prize</label>
          <label><input type="checkbox"> Grand Prix National des Lettres</label>
          <label><input type="checkbox"> IMPAC Dublin Literary Award</label>
          <label><input type="checkbox"> Independent Foreign Fiction Prize</label>
          <label><input type="checkbox"> International Booker Prize</label>
          <label><input type="checkbox"> National Book Award</label>
          <label><input type="checkbox"> Neustadt International Prize</label>
          <label><input type="checkbox"> Nobel Prize</label>
          <label><input type="checkbox"> Prix Goncourt</label>
          <label><input type="checkbox"> Prix Medicis</label>
          <label><input type="checkbox"> Pulitzer Prize</label>
        </div>
      </div>

      <div class="header-link dropdown" id="language-dropdown">
        <img class="filter-category-icon" src="icons/green/globe.svg" alt="Language Icon">
        Language
        <div class="dropdown-content">
          <label><input type="checkbox"> Afrikaans</label>
          <label><input type="checkbox"> Albanian</label>
          <label><input type="checkbox"> Arabic</label>
          <label><input type="checkbox"> Bahasa</label>
          <label><input type="checkbox"> Bengali</label>
          <label><input type="checkbox"> Bulgarian</label>
          <label><input type="checkbox"> Chinese</label>
          <label><input type="checkbox"> Croatian</label>
          <label><input type="checkbox"> Czech</label>
          <label><input type="checkbox"> Danish</label>
          <label><input type="checkbox"> Dutch</label>
          <label><input type="checkbox"> English</label>
          <label><input type="checkbox"> Finnish</label>
          <label><input type="checkbox"> French</label>
          <label><input type="checkbox"> Georgian</label>
          <label><input type="checkbox"> German</label>
          <label><input type="checkbox"> Greek</label>
          <label><input type="checkbox"> Hebrew</label>
          <label><input type="checkbox"> Hindi</label>
          <label><input type="checkbox"> Hungarian</label>
          <label><input type="checkbox"> Icelandic</label>
          <label><input type="checkbox"> Italian</label>
          <label><input type="checkbox"> Japanese</label>
          <label><input type="checkbox"> Kannada</label>
          <label><input type="checkbox"> Kiswahili</label>
          <label><input type="checkbox"> Korean</label>
          <label><input type="checkbox"> Malayalam</label>
          <label><input type="checkbox"> Norwegian</label>
          <label><input type="checkbox"> Persian</label>
          <label><input type="checkbox"> Polish</label>
          <label><input type="checkbox"> Portuguese</label>
          <label><input type="checkbox"> Punjabi</label>
          <label><input type="checkbox"> Romanian</label>
          <label><input type="checkbox"> Russian</label>
          <label><input type="checkbox"> Serbo-Croatian</label>
          <label><input type="checkbox"> Somali</label>
          <label><input type="checkbox"> Spanish</label>
          <label><input type="checkbox"> Swedish</label>
          <label><input type="checkbox"> Tamil</label>
          <label><input type="checkbox"> Turkish</label>
          <label><input type="checkbox"> Ukrainian</label>
          <label><input type="checkbox"> Urdu</label>
          <label><input type="checkbox"> Yiddish</label>
        </div>
      </div>

      <div class="header-link dropdown" id="century-slider">
        <img class="filter-category-icon" src="icons/green/calendar.svg" alt="Calendar Icon">
        Years
        <div class="dropdown-content">
          <div class="slider-labels">
            Showing authors alive during <div id="yearValue">1800—2025</div>
          </div>
          <div class="range-slider">
            <div class="slider-track-container">
              <div class="slider-track"></div>
            </div>
            <input type="range" min="1800" max="2025" value="1800" class="slider" id="yearMin">
            <input type="range" min="1800" max="2025" value="2025" class="slider" id="yearMax">
          </div>

        </div>
      </div>
      <div id="filter-clear-button" class="glass"><img width="16px" src="icons/x.svg" alt="Clear Filters"></div>

    </div>

    <div id="search-bar">
      <input id="search-input" type="text" placeholder="Search for authors or books" enterkeyhint="search">
      <button id="search-clear" type="button" class="search-clear" aria-label="Clear search">
        <img class="icon-x" src="icons/x.svg"></button>
    </div>

    <div id="header-buttons" class="header-controls">

      <button class="button-secondary only-on-small-screens" id="show-filters">
        <span>Filters</span>
        <div class="icon-circle"><img width="16px" src="icons/filter.svg" alt="Filter icon"></div>
      </button>

      <button class="button-secondary" id="btnRandom">
        <span>Feeling lucky</span>
        <div class="icon-circle"><img width="16px" src="icons/shuffle.svg" alt="Shuffle icon"></div>
      </button>

      <button class="button-secondary" id="helpButton">
        <span>Help</span>
        <div class="icon-circle"><img width="16px" src="icons/info.svg" alt="info"></div>
      </button>
    </div>

    <div id="helpContainer" class="about-container about-container-scrollable displaynone header-fade-in-down-fast">

      <button type="button" id="helpCloseButton">
        <img class="icon-circle-dark icon-circle-hover-mid-gray" src="icons/x.svg" width="20px" alt="info">
      </button>

      <h3 class="block-start-margin-0">About this Map</h3>

      <div class="about-content">
        <p>
          At Hammock, one of our core pillars is providing literary <a class="link-green"
            href="https://www.hammockmag.com/recommendations-lists/" target="_blank">recommendations</a> and curated
          lists to help readers
          discover new books. This interactive map is our latest endeavor to make exploring the world of literature
          engaging and intuitive.
        </p>
        <p>
          With this tool, you can journey across the globe and uncover nearly 800 fiction authors from the 20th and 21st
          centuries, offering a unique glimpse into the geographical roots and top books of some of the world&rsquo;s
          most
          celebrated writers. Using a range of awards, panel suggestions and other criteria, we&rsquo;ve picked out who
          we think
          are amongst the most essential writers of the past century and a half for you to explore.
        </p>

        <a href="https://www.hammockmag.com/methodology-1/blog-post-one" target="_blank">
          <button type="button" class="button-gray">
            Read About Our Methodology
            <img class="icon-circle-white" src="icons/arrow-up-right-gray.svg" width="16px" alt="info">
          </button>
        </a>

        <div class="pale-green-help">

          <div class="color-primary bold">How to Use this Map</div>
          <div class="help-instruction">
            <div class="icon-circle-mint">
              <img src="icons/green/maximize-2.svg" alt="Zoom icon">
            </div>
            Scroll and pinch to zoom in and out. Click and drag to move.
          </div>

          <div class="help-instruction">
            <div class="icon-circle-mint">
              <img src="icons/green/mouse-pointer.svg" alt="Mouse pointer icon">
            </div>
            Click green dots to find authors born in that area.
          </div>

          <div class="help-instruction">
            <div class="icon-circle-mint">
              <img src="icons/green/filter.svg" alt="Filter icon">
            </div>
            Use the top filters to refine results by continent, language, gender, awards and year-periods.
          </div>

          <div class="help-instruction">
            <div class="icon-circle-mint">
              <img src="icons/green/search.svg" alt="Search icon">
            </div>
            Type an author's name or book name in the search bar to see matching results
          </div>

          <div class="help-instruction">
            <div class="icon-circle-mint">
              <img src="icons/green/shuffle.svg" alt="Shuffle icon">
            </div>
            Click on 'Feeling Lucky' for a random author recommendation
          </div>

        </div>

        <span class="light-gray text-small">Crafted by</span>
        <a href="https://www.publicknowledge.co" target="_blank">
          <button type="button" class="button-pk">
            <img class="icon-circle-transparent rotate-on-hover on-hover-colorful" src="icons/pk.svg" width="22px"
              alt="info">
            Public Knowledge Studio
            <img class="icon-circle-transparent on-hover-colorful" src="icons/arrow-up-right-red.svg" width="16px"
              alt="info">
          </button>
        </a>

      </div>

    </div>
    </div>

  </header>

  <div id="sidebar" class="sidebar glass displaynone fade-in-up">

    <div id="sidebar-search-title-container" class="glass">
      <span id="sidebar-search-title">
        Result
      </span>
      <button onclick="toggleSidebar()" class="button-primary">
        <picture>
          <source media="(max-width: 500px)" srcset="icons/chevron-down.svg">
          <img id="chevron" width="20px" src="icons/chevron-up.svg">
        </picture>
      </button>
    </div>

    <div id="sidebar-search-results" class="sidebar-body"></div>

    <div id="sidebar-author-title" class="sidebar-title fade-in-right glass" onclick="backToTheResults()">
      <div class="flex-left">
        <img class="icon-left" src="icons/chevron-left.svg" alt="back">
        Back
      </div>
      <div class="icon-share" onclick="event.stopPropagation(); shareAuthor()">
        <img width="20px" class="icon-right" src="icons/green/share-2.svg" alt="share">
      </div>
    </div>

    <div id="sidebar-author-details" class="sidebar-author-details"></div>

  </div>

  <script>

    // Convenient names for the elements

    const aboutPkButton = document.getElementById('aboutPkButton');
    const aboutPk = document.getElementById('aboutPk');

    const logo = document.getElementById('logo');
    const showFilters = document.getElementById('show-filters');
    const filterContainer = document.getElementById('filter-container');
    const filterBackButton = document.getElementById('filter-back-button');
    const filterClearButton = document.getElementById('filter-clear-button');

    const searchBar = document.querySelector('#search-bar');
    const searchInput = document.getElementById('search-input');
    const searchClearButton = document.getElementById('search-clear');

    const searchtitle = document.getElementById('sidebar-search-title');
    const searchtitlecontainer = document.getElementById('sidebar-search-title-container');
    const searchresults = document.getElementById('sidebar-search-results');

    const sidebarauthortitle = document.getElementById('sidebar-author-title');
    const sidebarauthordetails = document.getElementById('sidebar-author-details');

    const titlechevron = document.getElementById('chevron');
    const headerButtons = document.getElementById('header-buttons');

    const aboutButton = document.getElementById('aboutButton');
    const aboutContainer = document.getElementById('aboutContainer');


    const helpButton = document.getElementById('helpButton');
    const helpContainer = document.getElementById('helpContainer');
    const helpCloseButton = document.getElementById('helpCloseButton');


    const tutorialBottom = document.getElementById('tutorial-bottom');

    const yearMin = document.getElementById('yearMin');
    const yearMax = document.getElementById('yearMax');
    const yearValue = document.getElementById('yearValue');

    const MOBILE_WIDTH = 500;

    let tutorialComplete = false;

    // Fetch the data.geojson file with the authors data
    fetch('data.geojson').then(response => response.json()).then(data => {
      window.data = data;
    });

    // TODO: Add constants for zoom levels.

    // Function to toggle dropdown content visibility
    function toggleDropdown(dropdownId) {
      // Close all other dropdowns first
      document.querySelectorAll('.dropdown').forEach(dropdown => {
        if (dropdown.id !== dropdownId) {
          dropdown.classList.remove('header-link-active');
          dropdown.querySelector('.dropdown-content').style.display = 'none';
        }
      });

      // Toggle the clicked dropdown
      const dropdown = document.getElementById(dropdownId);
      dropdown.classList.toggle('header-link-active');
      const dropdownContent = dropdown.querySelector('.dropdown-content');
      dropdownContent.style.display = dropdownContent.style.display === 'block' ? 'none' : 'block';
    }

    // Add click event listeners to all dropdown headers
    document.querySelectorAll('.dropdown').forEach(dropdown => {
      dropdown.addEventListener('click', (event) => {
        // Prevent the click from propagating to the document
        event.stopPropagation();
        toggleDropdown(dropdown.id);
      });
    });

    // Close all dropdowns when clicking outside
    document.addEventListener('click', () => {
      document.querySelectorAll('.dropdown').forEach(dropdown => {
        const content = dropdown.querySelector('.dropdown-content');
        content.style.display = 'none';
        dropdown.classList.remove('header-link-active');
      });
    });

    // Prevent clicks inside dropdown content from closing the dropdown
    document.querySelectorAll('.dropdown-content').forEach(content => {
      content.addEventListener('click', (event) => {
        event.stopPropagation();
      });
    });



    // Toggles the sidebar
    function toggleSidebar() {
      searchresults.style.display = searchresults.style.display === 'none' ? 'block' : 'none';
      titlechevron.style.rotate = titlechevron.style.rotate === '180deg' ? '0deg' : '180deg';
    }

    // Sets the sidebar title
    function setSidebarTitle(input) {
      searchtitle.innerHTML = input;
    }

    // Clears the sidebar
    function clearSidebar() {
      searchresults.innerHTML = "";
    }

    // Shows author details in sidebar
    function showAuthorDetails() {
      searchtitlecontainer.style.display = "none";
      searchresults.style.display = "none";

      sidebarauthortitle.style.display = "flex";
      sidebarauthordetails.style.display = "block";
    }

    // Shows results in sidebar
    function showSearchResults() {
      searchtitlecontainer.style.display = "flex";
      searchresults.style.display = "block";

      sidebarauthortitle.style.display = "none";
      sidebarauthordetails.style.display = "none";
    }

    // Shows results in sidebar and zooms out on map
    function backToTheResults() {
      if (!searchresults.style.display || searchresults.style.display === 'none') {
        map.easeTo({
          zoom: map.getZoom() - 0.5,
          duration: 500
        });
        showSearchResults();
      }
    }

    // Update the addAuthorResult function to include more details
    function addAuthorResult(properties, coordinates) {
      const {
        author_name,
        city_birth,
        city_residence,
        country,
        continent,
        year_birth,
        year_death,
        work_1,
        work_2,
        gender,
        language,
        awards,
        bio,
        list_title,
        list_bookname,
        list_copy,
        list_url
      } = properties;

      var authorDetails = `
        <div onclick="setAuthorDetails(${JSON.stringify(properties).replace(/"/g, '&quot;')}, ${coordinates[0]}, ${coordinates[1]})" 
             class="sidebar-author">
          <h3 class="author-name">${author_name}</h3>
          <h3 class="author-birth color-mid-green">${city_birth}</h3>
          <p class="text-label padtop light-gray">Author of</p>
          <p>${work_1}</p>
          <p>${work_2 || ''}</p>
        </div>`;
      searchresults.innerHTML += authorDetails;
    }

    // TODO: Remove this and the getOrdinalSuffix function, not being used anymore.
    // Function to get the century of a year
    function getCentury(year) {
      const century = Math.ceil(year / 100);
      return `${century}${getOrdinalSuffix(century)} Century`;
    }

    // Function to get the ordinal suffix of a number
    function getOrdinalSuffix(number) {
      const suffixes = ["th", "st", "nd", "rd"];
      const remainder = number % 100;
      const suffix = suffixes[(remainder - 20) % 10] || suffixes[remainder] || suffixes[0];
      return suffix;
    }

    // TODO: Remove country from this.
    // TODO: Consider not putting every value in this generator function so that search is faster.
    // Update setAuthorDetails to show more information
    function setAuthorDetails(properties, lat, long) {
      const {
        author_name,
        city_birth,
        city_residence,
        country,
        continent,
        year_birth,
        year_death,
        work_1,
        work_2,
        gender,
        language,
        awards,
        bio,
        list_title,
        list_bookname,
        list_copy,
        list_url
      } = properties;

      map.flyTo({
        center: [lat, long],
        zoom: 6
      });

      showAuthorDetails();

      // Create awards pill if awards exist
      const awardPills = awards ? awards.split(';').map(award => `<span class="pill">${award}</span>`).join('') : '';

      // Create language pill(s)
      const languagePills = language.split(';').map(lang =>
        `<span class="pill">${lang.trim()}</span>`
      ).join('');

      const featuredIn = list_title ? `
      
        <a href="${list_url}" target="_blank"><div class="card-title">${list_title}
          <img src="icons/arrow-up-right.svg" alt="arrow-up-right">
          </div>
          </a>
        <div class="card-content">
          <span class="book-title">${list_bookname}</span>
          <span>${list_copy}</span>
        </div>
      ` : '';

      sidebarauthordetails.innerHTML = `
        <h2>${author_name}</h2>
        <div class="lifetime">(${year_birth} - ${year_death ? year_death : 'Present'})</div>

        <div class="pill-container">
          <span class="pill">${continent}</span>
          <span class="pill">${gender}</span>
          ${languagePills}
          ${awardPills}
        </div>

        <p class="text-label padtop mid-gray">Author of</p>
        <p class="book">${work_1}</p>
        ${work_2 ? `<p class="book">${work_2}</p>` : ''}

        <div class="flex-equal">
          <div class="flex-1">
            <p class="text-label padtop mid-gray">Born in</p>
            <span class="color-mid-green">${city_birth}</span>
          </div>
          <div class="flex-1">
            <p class="text-label padtop mid-gray">${year_death ? 'Died in' : 'Lives in'}</p>
            <span class="color-mid-green">${city_residence}</span>
          </div>
        </div>

        ${bio ? `<p class="text-label padtop mid-gray">Bio</p><p class="bio">${bio}</p>` : ''}
        ${featuredIn}
      `;

    }

    // TODO: Obfuscate this access token somehow.
    // Mapbox access token
    mapboxgl.accessToken = 'pk.eyJ1IjoiZ3lhbmwiLCJhIjoiY204bGgwM2N5MTgyODJpc2ZsN25heXd1aSJ9.YN3cOToweo8kn1SkiMxARw';

    // Initialize the map
    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/gyanl/cls90czva01au01pld9fc7b5x',
      center: [2.0000, 89.0000],
      zoom: .5
    });

    // Move this function outside of map.on('load')
    async function showVisibleFeatures() {
      clearSidebar();
      const features = [];
      const displayLimit = 100;

      // Get visible features
      const visibleFeatures = map.queryRenderedFeatures({
        layers: ['clusters', 'unclustered-point']
      });

      // Handle unclustered points first (faster)
      const unclusteredFeatures = visibleFeatures
        .filter(feature => !feature.properties.cluster && feature.properties.author_name);

      // If we already have enough unclustered points, we can skip cluster processing
      if (unclusteredFeatures.length >= displayLimit) {
        showResults(unclusteredFeatures);
        return;
      }

      features.push(...unclusteredFeatures);

      // Process clusters only if we need more results
      const clusterPromises = visibleFeatures
        .filter(feature => feature.properties.cluster)
        .map(feature => {
          return new Promise((resolve, reject) => {
            map.getSource('authors').getClusterLeaves(
              feature.properties.cluster_id,
              displayLimit, // Only request up to displayLimit
              0,
              (err, leaves) => err ? reject(err) : resolve(leaves)
            );
          });
        });

      try {
        const clusterResults = await Promise.all(clusterPromises);
        clusterResults.forEach(clusterPoints => {
          features.push(...clusterPoints);
        });

        // Deduplicate results
        const seen = new Set();
        const uniqueFeatures = features.filter(feature => {
          const authorName = feature.properties.author_name;
          if (!authorName || seen.has(authorName)) return false;
          seen.add(authorName);
          return true;
        });

        showResults(uniqueFeatures);
      } catch (error) {
        console.error('Error getting cluster data:', error);
      }

      console.log('[showVisibleFeatures] -> showResults() called, map flyTo zoom=3');
    }

    // Also move showResults function outside map.on('load')
    function showResults(features) {
      clearSidebar();
      const totalCount = features.length;
      const displayLimit = 100;

      // Track authors we've already added
      const addedAuthors = new Set();
      let displayedCount = 0;

      for (const feature of features) {
        if (displayedCount >= displayLimit) break;

        if (feature.properties?.author_name &&
          !addedAuthors.has(feature.properties.author_name)) {
          addAuthorResult(
            feature.properties,
            feature.geometry.coordinates
          );
          addedAuthors.add(feature.properties.author_name);
          displayedCount++;
        }
      }

      // Update sidebar title to show total count
      if (totalCount > 0) {
        setSidebarTitle(`${totalCount > displayLimit ? `${displayLimit}+ authors` : `${totalCount} authors`}`);
      } else {
        setSidebarTitle("No authors found");
        searchresults.innerHTML = `
          <div class="sidebar-empty">
            <h3>No matching results in this area.</h3>
            <p>Try zooming out for a wider view, exploring other regions, or adjusting the filters.</p>
            <p>If you believe an author from this area should be in our database, fill out this <a class="link-green-light" href="https://forms.gle/95KHAgojvKXRZ8kW8" target="_blank">form</a> to let us know!</p>
          </div>
        `;
      }
    }

    // Move applyFilters function outside map.on('load')
    function applyFilters() {
      const searchValue = searchInput.value.toLowerCase();
      const activeFilters = getActiveFilters();
      const minYear = parseInt(yearMin.value);
      const maxYear = parseInt(yearMax.value);

      const filteredFeatures = window.data.features.filter(f => {
        const props = f.properties;

        // Add year range filter
        const birthYear = parseInt(props.year_birth);
        const deathYear = props.year_death ? parseInt(props.year_death) : new Date().getFullYear();
        const wasAliveInRange = (
          (birthYear <= maxYear && deathYear >= minYear) // Check if author's life overlapped with selected range
        );

        // Existing filter checks
        const matchesSearch = searchValue.length <= 1 ||
          props.author_name.toLowerCase().includes(searchValue) ||
          props.work_1.toLowerCase().includes(searchValue) ||
          (props.work_2 && props.work_2.toLowerCase().includes(searchValue)) ||
          props.city_birth.toLowerCase().includes(searchValue) ||
          props.city_residence.toLowerCase().includes(searchValue);

        const matchesGender = activeFilters.gender.length === 0 ||
          activeFilters.gender.includes(props.gender.toLowerCase());
        const matchesContinent = activeFilters.continent.length === 0 ||
          activeFilters.continent.includes(props.continent);
        const matchesLanguage = activeFilters.language.length === 0 ||
          (props.language && props.language.split(';').some(lang =>
            activeFilters.language.includes(lang.trim())));
        const matchesAwards = activeFilters.awards.length === 0 ||
          (props.awards && props.awards.split(';').some(award =>
            activeFilters.awards.includes(award.trim())));

        // Include year range in final check
        return matchesSearch && matchesGender && matchesContinent &&
          matchesLanguage && matchesAwards && wasAliveInRange;
      });

      // Create a fresh GeoJSON with filtered features
      const newData = {
        ...window.data,
        features: filteredFeatures
      };

      // Update the map source with filtered data
      map.getSource('authors').setData(newData);

      // Update sidebar with the newly filtered features
      showResults(filteredFeatures);
      backToTheResults();
    }

    // Also move getActiveFilters outside map.on('load')
    function getActiveFilters() {
      const filters = {
        gender: [],
        continent: [],
        language: [],
        awards: []
      };

      // Collect checked values using label text instead of IDs
      document.querySelectorAll('#gender-dropdown input:checked').forEach(checkbox => {
        filters.gender.push(checkbox.closest('label').textContent.trim().toLowerCase());
      });

      document.querySelectorAll('#continent-dropdown input:checked').forEach(checkbox => {
        filters.continent.push(checkbox.closest('label').textContent.trim());
      });

      document.querySelectorAll('#language-dropdown input:checked').forEach(checkbox => {
        filters.language.push(checkbox.closest('label').textContent.trim());
      });

      document.querySelectorAll('#awards-dropdown input:checked').forEach(checkbox => {
        filters.awards.push(checkbox.closest('label').textContent.trim());
      });

      return filters;
    }

    // Add this after map initialization
    map.on('load', function () {


      // If the user clicks intro buttom, start the experience
      document.getElementById('introButton').addEventListener('click', startExperience);

      // Start the experience by animating out the tutorial parts
      function startExperience(lat, long) {
        clearSidebar(); //so that the sidebar doesn't show the no results message
        tutorialComplete = true;
        introText.classList.replace("header-fade-in-up", "goAwayTop");
        tutorialBottom.classList.replace("header-fade-in-down", "goAwayBottom");
        aboutButton.style.display = 'none';
        // If lat and long are provided, use them. Otherwise use default coordinates
        const targetCoords = (lat && long)
          ? [long, lat]
          : [78.0000, 29.0000];

        // Use easeTo for default case, flyTo for specific coordinates
        if (lat && long) {
          map.flyTo({
            center: targetCoords,
            zoom: 4,
            duration: 1600
          });
        } else {
          map.easeTo({
            center: targetCoords,
            zoom: 4,
            duration: 1600
          });
        }

        // Wait some time and then show the sidebar and remove the intro button and text
        setTimeout(() => {
          document.getElementById('header').classList.remove('displaynone');
          document.getElementById('sidebar').classList.remove('displaynone');
          introText.style.display = 'none';
          tutorialBottom.style.display = 'none';
        }, 900);
      }

      // Rest of your existing map.on('load') code...
      map.addSource('authors', {
        type: 'geojson',
        data: 'data.geojson', // Path to GeoJSON file
        cluster: true,
        clusterMaxZoom: 14, // Max zoom to cluster points on
        clusterRadius: 50 // Radius of each cluster when clustering points (defaults to 50)
      });

      // Use Mapbox GL JS's 'addLayer' function to add the points to the map.
      map.addLayer({
        id: 'clusters',
        type: 'circle',
        source: 'authors',
        filter: ['has', 'point_count'],
        //Probably don't need this actually
        paint: {
          'circle-color': '#67FAAF',
          //Step function to set radius of unclustered circles
          'circle-radius': [
            'step',
            ['get', 'point_count'],
            15,
            10,
            20,
            20,
            30,
            30,
            40
          ]
        }
      });

      //Clustered circles
      map.addLayer({
        id: 'cluster-count',
        type: 'symbol',
        source: 'authors',
        filter: ['has', 'point_count'],
        layout: {
          'text-field': '{point_count_abbreviated}',
          'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
          'text-size': 16,
        }
      });

      //Unclustered Points
      map.addLayer({
        id: 'unclustered-point',
        type: 'circle',
        source: 'authors',
        filter: ['!', ['has', 'point_count']],
        paint: {
          'circle-color': '#67FAAF',
          'circle-radius': 10,
        }
      });

      // Clicking on a point displays the author details in the sidebar
      map.on('click', 'unclustered-point', function (e) {

        if (!tutorialComplete) {
          startExperience(e.lngLat.lat, e.lngLat.lng);
          return;
        }

        var coordinates = e.features[0].geometry.coordinates.slice();
        var properties = e.features[0].properties;

        setSidebarTitle("1 result");
        clearSidebar();
        addAuthorResult(properties, coordinates);
        showSearchResults();

        while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
          coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
        }
      });

      // Clicking on a cluster displays all points in cluster in sidebar
      map.on('click', 'clusters', function (e) {
        if (!tutorialComplete) {
          startExperience(e.lngLat.lat, e.lngLat.lng);
        }

        var features = map.queryRenderedFeatures(e.point, {
          layers: ['clusters']
        });
        var clusterId = features[0].properties.cluster_id;
        map.getSource('authors').getClusterLeaves(clusterId, 103, 0, function (err, leaves) {
          if (err) {
            return console.error('Error getting leaves of cluster: ', err);
          }
          clearSidebar();
          setSidebarTitle(leaves.length + " authors");
          leaves.forEach(function (leaf) {
            addAuthorResult(
              leaf.properties,
              leaf.geometry.coordinates
            );
          });
        });
        showSearchResults();
      });

      // Debounce helper function
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Debounced function to update results when any filter changes
      const updateFilteredResults = debounce(() => {
        clearSidebar();
        backToTheResults();
        applyFilters();
      }, 150);

      // Set up event listeners
      searchInput.addEventListener('input', updateFilteredResults);

      document.querySelectorAll('.dropdown input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', () => {
          applyFilters();

          // Update the count badge
          const dropdownId = checkbox.closest('.dropdown').id;
          updateDropdownCount(dropdownId);
        });
      });


      // Update event listeners
      document.getElementById('search-bar').addEventListener('input', updateFilteredResults);
      map.on('moveend', debounce(showVisibleFeatures, 100));
      map.on('zoomend', debounce(showVisibleFeatures, 100));

      // Initial load
      showVisibleFeatures();

      aboutPkButton.addEventListener('mouseover', () => {
        // Only for desktop
        if (window.innerWidth >= MOBILE_WIDTH) {
          aboutPk.classList.remove('displaynone');
        }
      });

      aboutPkButton.addEventListener('mouseout', () => {
        aboutPk.classList.add('displaynone');
      });

      searchClearButton.addEventListener('click', () => {
        // Clear the search box
        searchInput.value = '';
        searchInput.blur();

        // Reapply filters to update the map with filtered data
        applyFilters();
        backToTheResults();

        // Handle display logic for mobile when search clear button is clicked
        // todo
        logo.style.display = 'flex';

      });

      aboutButton.addEventListener('click', () => {
        const isHidden = aboutContainer.classList.contains('displaynone');
        aboutContainer.classList.toggle('displaynone');

        if (isHidden) {
          // Only add the document listener when opening the container
          document.addEventListener('click', handleOutsideClick);
        } else {
          // Remove the listener when closing the container
          document.removeEventListener('click', handleOutsideClick);
        }
      });

      helpButton.addEventListener('click', () => {
        const isHidden = helpContainer.classList.contains('displaynone');
        helpContainer.classList.toggle('displaynone');


        if (isHidden) {
          // Only add the document listener when opening the container
          document.addEventListener('click', handleOutsideClick);
        } else {
          // Remove the listener when closing the container
          document.removeEventListener('click', handleOutsideClick);
        }
      });

      helpCloseButton.addEventListener('click', () => {
        helpContainer.classList.add('displaynone');
      });

    });



    // Fly to a random filtered location on the map when feeling lucky button is clicked
    document.getElementById('btnRandom').addEventListener('click', () => {
      // Get currently filtered features based on active filters
      const searchValue = searchInput.value.toLowerCase();
      const activeFilters = getActiveFilters();
      const minYear = parseInt(yearMin.value);
      const maxYear = parseInt(yearMax.value);

      const filteredFeatures = window.data.features.filter(f => {
        const props = f.properties;

        // Add year range filter
        const birthYear = parseInt(props.year_birth);
        const deathYear = props.year_death ? parseInt(props.year_death) : new Date().getFullYear();
        const wasAliveInRange = (
          (birthYear <= maxYear && deathYear >= minYear) // Check if author's life overlapped with selected range
        );

        // Existing filter checks
        const matchesSearch = searchValue.length <= 1 ||
          props.author_name.toLowerCase().includes(searchValue) ||
          props.work_1.toLowerCase().includes(searchValue) ||
          (props.work_2 && props.work_2.toLowerCase().includes(searchValue)) ||
          props.city_birth.toLowerCase().includes(searchValue) ||
          props.city_residence.toLowerCase().includes(searchValue);

        const matchesGender = activeFilters.gender.length === 0 ||
          activeFilters.gender.includes(props.gender.toLowerCase());
        const matchesContinent = activeFilters.continent.length === 0 ||
          activeFilters.continent.includes(props.continent);
        const matchesLanguage = activeFilters.language.length === 0 ||
          (props.language && props.language.split(';').some(lang =>
            activeFilters.language.includes(lang.trim())));
        const matchesAwards = activeFilters.awards.length === 0 ||
          (props.awards && props.awards.split(';').some(award =>
            activeFilters.awards.includes(award.trim())));

        return matchesSearch && matchesGender && matchesContinent &&
          matchesLanguage && matchesAwards && wasAliveInRange;
      });

      if (filteredFeatures.length === 0) {
        console.log('No filtered features found');
        return;
      }

      // Select random feature from filtered ones
      const randomFeature = filteredFeatures[
        Math.floor(Math.random() * filteredFeatures.length)
      ];

      if (randomFeature && randomFeature.geometry) {
        // Clear author details first
        sidebar.style.display = 'none';

        // Create one-time event listener for moveend
        const onMoveEnd = () => {
          setAuthorDetails(
            randomFeature.properties,
            randomFeature.geometry.coordinates[0],
            randomFeature.geometry.coordinates[1]
          );
          sidebar.style.display = 'block';
          // Remove the listener after it fires once
          map.off('moveend', onMoveEnd);
        };

        // Add the listener
        map.on('moveend', onMoveEnd);

        // Start the animation
        map.flyTo({
          center: randomFeature.geometry.coordinates,
          zoom: 6
        });
      }
    });

    // Function to update the count badge for a dropdown
    function updateDropdownCount(dropdownId) {
      const dropdown = document.getElementById(dropdownId);
      const checkedBoxes = dropdown.querySelectorAll('input[type="checkbox"]:checked').length;

      if (checkedBoxes > 0) {
        dropdown.setAttribute('data-count', checkedBoxes);
        dropdown.classList.add('has-count');
      } else {
        dropdown.removeAttribute('data-count');
        dropdown.classList.remove('has-count');
      }

      // Add total count to showFilters if it exists
      if (showFilters) {
        // Get all checked boxes across all dropdowns
        const totalCheckedBoxes = document.querySelectorAll('.dropdown input[type="checkbox"]:checked').length;
        if (totalCheckedBoxes > 0) {
          showFilters.setAttribute('data-count', totalCheckedBoxes);
          showFilters.classList.add('has-count');
        } else {
          showFilters.removeAttribute('data-count');
          showFilters.classList.remove('has-count');
        }
      }
    }

    // Handling mobile dropdowns differently
    function setupMobileDropdowns() {
      if (window.innerWidth <= MOBILE_WIDTH) {
        // Close dropdown when clicking outside
        document.addEventListener('click', (event) => {
          if (!event.target.closest('.dropdown')) {
            document.querySelectorAll('.dropdown-content').forEach(content => {
              content.style.display = 'none';
            });
            document.querySelectorAll('.dropdown').forEach(dropdown => {
              dropdown.classList.remove('header-link-active');
            });
          }
        });

        // Prevent body scroll when dropdown is open
        document.querySelectorAll('.dropdown').forEach(dropdown => {
          dropdown.addEventListener('click', () => {
            if (dropdown.classList.contains('header-link-active')) {
              document.body.style.overflow = 'hidden';
            } else {
              document.body.style.overflow = '';
            }
          });
        });
      }
    }

    // Call this function when the page loads and on resize
    window.addEventListener('load', setupMobileDropdowns);
    window.addEventListener('resize', setupMobileDropdowns);



    document.addEventListener('DOMContentLoaded', () => {

      // Show/hide clear button based on input content
      searchInput.addEventListener('input', () => {
        if (window.innerWidth >= MOBILE_WIDTH) {
          searchClearButton.style.display = searchInput.value ? 'block' : 'none';
        }
      });

      // Initialize clear button visibility
      if (window.innerWidth >= MOBILE_WIDTH) {
        searchClearButton.style.display = searchInput.value ? 'block' : 'none';
      }

      // When search bar is clicked, hide logo and filter on mobile
      searchBar.addEventListener('click', () => {
        searchClearButton.style.display = 'block';
      });

      //todo

      showFilters.addEventListener('click', () => {
        filterContainer.classList.remove('only-on-big-screens');
        logo.classList.add('only-on-big-screens');
        headerButtons.classList.add('only-on-big-screens');
        searchBar.classList.add('only-on-big-screens');
      });

      filterBackButton.addEventListener('click', () => {
        filterContainer.classList.add('only-on-big-screens');
        logo.classList.remove('only-on-big-screens');
        headerButtons.classList.remove('only-on-big-screens');
        searchBar.classList.remove('only-on-big-screens');
      });

      filterClearButton.addEventListener('click', () => {
        // Uncheck all checkbox filters
        document.querySelectorAll('input[type="checkbox"]:checked').forEach(checkbox => {
          checkbox.checked = false;
        });
      
        // Alert user that filters have been cleared
        showToast('All filters cleared.');

        document.querySelectorAll('.dropdown').forEach(dropdown => {
          const checkedBoxes = dropdown.querySelectorAll('input[type="checkbox"]:checked').length;
          if (checkedBoxes > 0) {
            dropdown.setAttribute('data-count', checkedBoxes);
            dropdown.classList.add('has-count');
          } else {
            dropdown.removeAttribute('data-count');
            dropdown.classList.remove('has-count');
          }
        });

        // Reset the year range slider to its initial state
        yearMin.value = '1800';
        yearMax.value = '2025';
        yearValue.textContent = '1800—2025';

        // Trigger input event to update the track UI
        yearMin.dispatchEvent(new Event('input'));
        yearMax.dispatchEvent(new Event('input'));

        applyFilters();
        backToTheResults();
      });

    });


    // Add this debounce function with your other utility functions
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Modify the setupYearRangeSlider function
    function setupYearRangeSlider() {
      const debouncedApplyFilters = debounce(applyFilters, 250);
      const track = document.querySelector('.slider-track');

      function updateTrack() {
        const minVal = parseInt(yearMin.value);
        const maxVal = parseInt(yearMax.value);
        const minPercent = ((minVal - 1800) / (2025 - 1800)) * 100;
        const maxPercent = ((maxVal - 1800) / (2025 - 1800)) * 100;

        track.style.setProperty('--start-percent', `${minPercent}%`);
        track.style.setProperty('--end-percent', `${maxPercent}%`);
      }

      yearMin.addEventListener('input', (e) => {
        const minVal = parseInt(yearMin.value);
        const maxVal = parseInt(yearMax.value);

        if (minVal > maxVal) {
          yearMin.value = maxVal;
          return;
        }

        yearValue.textContent = `${minVal}—${maxVal}`;
        updateTrack();
        debouncedApplyFilters();
      });

      yearMax.addEventListener('input', (e) => {
        const minVal = parseInt(yearMin.value);
        const maxVal = parseInt(yearMax.value);

        if (maxVal < minVal) {
          yearMax.value = minVal;
          return;
        }

        yearValue.textContent = `${minVal}—${maxVal}`;
        updateTrack();
        debouncedApplyFilters();
      });

      // Initialize track
      updateTrack();
    }

    // Call setupYearRangeSlider when the page loads
    document.addEventListener('DOMContentLoaded', setupYearRangeSlider);

    // Add this after your existing checkbox event listeners
    document.querySelectorAll('#continent-dropdown input[type="checkbox"]').forEach(checkbox => {
      checkbox.addEventListener('change', (e) => {
        if (e.target.checked) {
          // Only fly to location if checkbox is being checked
          const continent = e.target.closest('label').textContent.trim();
          const continentCoordinates = {
            'Africa': [17.5707, 3.8690],
            'Asia': [100.6197, 34.0479],
            'Australia': [133.7751, -25.2744],
            'Europe': [15.2551, 54.5260],
            'North America': [-105.2551, 54.5260],
            'Latin America': [-58.9300, -23.4425]
          };

          if (continentCoordinates[continent]) {
            map.flyTo({
              center: continentCoordinates[continent],
              zoom: 2.5,
              duration: 1500
            });
          }
        }

        // Apply filters regardless of checked state
        applyFilters();
        updateDropdownCount('continent-dropdown');
      });
    });

    // Add single event listener for clicks outside aboutContainer
    const handleOutsideClick = (event) => {
      if (!event.target.closest('#aboutContainer') && !event.target.closest('#aboutButton')) {
        aboutContainer.classList.add('displaynone');
      }
    };

    // Add this to your existing script
    window.addEventListener('resize', () => {
      const searchInput = document.getElementById('search-input');
      if (window.innerWidth <= 700) {
        searchInput.placeholder = "Search";
      } else {
        searchInput.placeholder = "Search for authors or books";
      }
    });

    // Also trigger it on load
    window.dispatchEvent(new Event('resize'));


    function shareAuthor() {
      const authorName = document.querySelector('.sidebar-author-details h2').textContent;
      const shareText = `I just discovered ${authorName} on the Literary Map by Hammock Magazine. Find incredible authors from around the world at`;
      const shareUrl = 'https://map.hammockmagazine.com/';

      // 1. Web Share API (modern browsers, mobile-friendly)
      if (navigator.share) {
        navigator.share({
          title: 'Literary Map by Hammock',
          text: shareText,
          url: shareUrl
        }).catch(console.error);
        return;
      }

      // 2. Platform-specific share URLs (fallback)
      const sharePlatforms = {
        twitter: `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareText)}&url=${encodeURIComponent(shareUrl)}`,
        facebook: `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(shareUrl)}`,
        linkedin: `https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(shareUrl)}`,
        whatsapp: `https://wa.me/?text=${encodeURIComponent(`${shareText} ${shareUrl}`)}`
      };

      // Create and show a sharing menu
      const menu = document.createElement('div');
      menu.className = 'share-menu glass';
      menu.innerHTML = `
        <div class="share-menu-title">Share this author</div>
        <button onclick="window.open('${sharePlatforms.twitter}', '_blank')" class="share-button">
          <img src="icons/twitter.svg" alt="Twitter">Twitter
        </button>
        <button onclick="window.open('${sharePlatforms.facebook}', '_blank')" class="share-button">
          <img src="icons/facebook.svg" alt="Facebook">Facebook
        </button>
        <button onclick="window.open('${sharePlatforms.linkedin}', '_blank')" class="share-button">
          <img src="icons/linkedin.svg" alt="LinkedIn">LinkedIn
        </button>
        <button onclick="window.open('${sharePlatforms.whatsapp}', '_blank')" class="share-button">
          <img src="icons/whatsapp.svg" alt="WhatsApp">WhatsApp
        </button>
        <button onclick="copyToClipboard('${shareText} ${shareUrl}')" class="share-button">
          <img src="icons/copy.svg" alt="Copy">Copy Link
        </button>
      `;

      // Position and show the menu
      document.body.appendChild(menu);

      // Close menu when clicking outside
      const closeMenu = (e) => {
        if (!menu.contains(e.target) && !e.target.closest('.icon-share')) {
          menu.remove();
          document.removeEventListener('click', closeMenu);
        }
      };
      
      // Add small delay before adding click listener to prevent immediate closing
      setTimeout(() => {
        document.addEventListener('click', closeMenu);
      }, 0);
    }

    function copyToClipboard(text) {
      // Try using the modern Clipboard API first
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(text).then(() => showToast('Link copied to clipboard'));
        return;
      }

      // Fallback: Create temporary textarea element
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.left = '-999999px';
      textArea.style.top = '-999999px';
      document.body.appendChild(textArea);
      
      // Select and copy
      textArea.focus();
      textArea.select();
      try {
        document.execCommand('copy');
        showToast('Link copied to clipboard');
      } catch (err) {
        console.error('Failed to copy text: ', err);
        showToast('Failed to copy link');
      }
      
      // Cleanup
      textArea.remove();
    }

    function showToast(message) {
      const toast = document.createElement('div');
      toast.className = 'toast-notification glass';
      toast.textContent = message;
      document.body.appendChild(toast);
      
      setTimeout(() => {
        toast.classList.add('fade-out');
        setTimeout(() => toast.remove(), 300);
      }, 2000);
    }
  </script>

</body>

</html>